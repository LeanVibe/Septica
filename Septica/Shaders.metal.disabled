//
//  Shaders.metal
//  Septica
//
//  Enhanced Metal shaders for Romanian Septica card game
//  Provides premium visual effects for card rendering and animations
//

// File for Metal kernel and shader functions

#include <metal_stdlib>
#include <simd/simd.h>

// Including header shared between this Metal shader code and Swift/C code executing Metal API commands
#import "ShaderTypes.h"

using namespace metal;

// MARK: - Vertex Input/Output Structures

typedef struct
{
    float3 position [[attribute(VertexAttributePosition)]];
    float2 texCoord [[attribute(VertexAttributeTexcoord)]];
} Vertex;

typedef struct
{
    float4 position [[position]];
    float2 texCoord;
    float3 worldPos;
} ColorInOut;

typedef struct
{
    float4 position [[position]];
    float2 texCoord;
    float4 color;
    float alpha;
} ParticleOut;

// MARK: - Card Rendering Shaders

vertex ColorInOut cardVertexShader(Vertex in [[stage_in]],
                                   constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]])
{
    ColorInOut out;

    float4 position = float4(in.position, 1.0);
    out.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * position;
    out.texCoord = in.texCoord;
    out.worldPos = (uniforms.modelViewMatrix * position).xyz;

    return out;
}

fragment float4 cardFragmentShader(ColorInOut in [[stage_in]],
                                   constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]],
                                   texture2d<half> cardTexture [[ texture(TextureIndexColor) ]])
{
    constexpr sampler cardSampler(mip_filter::linear,
                                  mag_filter::linear,
                                  min_filter::linear);

    half4 cardColor = cardTexture.sample(cardSampler, in.texCoord.xy);
    
    // Add subtle card edge glow for Romanian elegance
    float2 center = float2(0.5, 0.5);
    float distance = length(in.texCoord - center);
    float edgeGlow = smoothstep(0.4, 0.5, distance) * 0.1;
    
    // Romanian traditional colors enhancement
    float3 romanianGold = float3(1.0, 0.84, 0.0);
    float3 romanianRed = float3(0.8, 0.2, 0.2);
    
    // Enhance card colors based on suit
    float3 enhancedColor = cardColor.rgb;
    
    // Add warm lighting for traditional feel
    float3 warmLight = float3(1.05, 1.02, 0.98);
    enhancedColor *= warmLight;
    
    return float4(enhancedColor + edgeGlow, cardColor.a);
}

// MARK: - Card Selection Highlight Shader

fragment float4 cardHighlightShader(ColorInOut in [[stage_in]],
                                     constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]],
                                     texture2d<half> cardTexture [[ texture(TextureIndexColor) ]])
{
    constexpr sampler cardSampler(mip_filter::linear,
                                  mag_filter::linear,
                                  min_filter::linear);

    half4 cardColor = cardTexture.sample(cardSampler, in.texCoord.xy);
    
    // Golden selection highlight for Romanian elegance
    float2 center = float2(0.5, 0.5);
    float distance = length(in.texCoord - center);
    
    // Pulsing golden border
    float time = uniforms.modelViewMatrix[3][3]; // Use matrix component as time
    float pulse = sin(time * 6.0) * 0.5 + 0.5;
    float border = smoothstep(0.45, 0.5, distance) * pulse;
    
    float3 goldHighlight = float3(1.0, 0.84, 0.2) * border * 0.6;
    
    return float4(cardColor.rgb + goldHighlight, cardColor.a);
}

// MARK: - Card Animation Shaders

vertex ColorInOut cardFlipVertexShader(Vertex in [[stage_in]],
                                        constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]])
{
    ColorInOut out;
    
    float4 position = float4(in.position, 1.0);
    
    // Apply flip rotation around Y-axis
    float flipAngle = uniforms.modelViewMatrix[0][3]; // Use matrix component as flip angle
    float cosAngle = cos(flipAngle);
    float sinAngle = sin(flipAngle);
    
    // Flip transformation
    position.x *= cosAngle;
    position.z = position.x * sinAngle;
    
    out.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * position;
    out.texCoord = in.texCoord;
    out.worldPos = (uniforms.modelViewMatrix * position).xyz;
    
    return out;
}

// MARK: - Particle System for Romanian Cultural Effects

vertex ParticleOut particleVertexShader(Vertex in [[stage_in]],
                                         constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]])
{
    ParticleOut out;
    
    float4 position = float4(in.position, 1.0);
    out.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * position;
    out.texCoord = in.texCoord;
    
    // Traditional Romanian colors for celebrations
    float3 romanianColors[4] = {
        float3(0.8, 0.2, 0.2),  // Deep red
        float3(1.0, 0.84, 0.0), // Gold
        float3(0.2, 0.4, 0.8),  // Royal blue
        float3(0.9, 0.9, 0.9)   // Silver
    };
    
    int colorIndex = int(in.position.z) % 4;
    out.color = float4(romanianColors[colorIndex], 1.0);
    
    // Fade based on age/distance
    float distance = length(in.position.xy);
    out.alpha = 1.0 - smoothstep(0.0, 2.0, distance);
    
    return out;
}

fragment float4 particleFragmentShader(ParticleOut in [[stage_in]])
{
    // Create circular particles
    float2 center = float2(0.5, 0.5);
    float distance = length(in.texCoord - center);
    
    if (distance > 0.5) {
        discard_fragment();
    }
    
    // Soft circular particle with alpha falloff
    float alpha = (1.0 - distance * 2.0) * in.alpha;
    
    return float4(in.color.rgb, alpha);
}

// MARK: - Romanian Pattern Overlay Shader

fragment float4 romanianPatternShader(ColorInOut in [[stage_in]],
                                       constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]],
                                       texture2d<half> cardTexture [[ texture(TextureIndexColor) ]])
{
    constexpr sampler cardSampler(mip_filter::linear,
                                  mag_filter::linear,
                                  min_filter::linear);

    half4 cardColor = cardTexture.sample(cardSampler, in.texCoord.xy);
    
    // Traditional Romanian geometric patterns
    float2 scaledCoord = in.texCoord * 8.0;
    float pattern1 = sin(scaledCoord.x) * sin(scaledCoord.y);
    float pattern2 = cos(scaledCoord.x + scaledCoord.y) * 0.5;
    
    // Subtle pattern overlay
    float patternStrength = (pattern1 + pattern2) * 0.02;
    
    // Romanian traditional color tints
    float3 patternColor = float3(0.9, 0.85, 0.7); // Warm beige
    
    float3 finalColor = cardColor.rgb + (patternColor * patternStrength);
    
    return float4(finalColor, cardColor.a);
}

// MARK: - Performance Optimized Basic Shaders

vertex ColorInOut basicVertexShader(Vertex in [[stage_in]],
                                     constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]])
{
    ColorInOut out;

    float4 position = float4(in.position, 1.0);
    out.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * position;
    out.texCoord = in.texCoord;
    out.worldPos = (uniforms.modelViewMatrix * position).xyz;

    return out;
}

fragment float4 basicFragmentShader(ColorInOut in [[stage_in]],
                                     constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]],
                                     texture2d<half> colorMap [[ texture(TextureIndexColor) ]])
{
    constexpr sampler colorSampler(mip_filter::linear,
                                   mag_filter::linear,
                                   min_filter::linear);

    half4 colorSample = colorMap.sample(colorSampler, in.texCoord.xy);

    return float4(colorSample);
}

// MARK: - Legacy Compatibility Shaders

vertex ColorInOut vertexShader(Vertex in [[stage_in]],
                               constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]])
{
    return basicVertexShader(in, uniforms);
}

fragment float4 fragmentShader(ColorInOut in [[stage_in]],
                               constant Uniforms & uniforms [[ buffer(BufferIndexUniforms) ]],
                               texture2d<half> colorMap [[ texture(TextureIndexColor) ]])
{
    return basicFragmentShader(in, uniforms, colorMap);
}
